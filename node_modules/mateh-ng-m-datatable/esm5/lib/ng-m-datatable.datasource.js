import { __extends, __read, __spread } from "tslib";
import { DataSource } from "@angular/cdk/collections";
import { map } from "rxjs/operators";
import { of as observableOf, merge } from "rxjs";
// TODO: Replace this with your own data model type
// export interface DataTableItem {
//   name: string;
//   id: number;
// }
/**
 * Data source for the DataTable view. This class should
 * encapsulate all logic for fetching and manipulating the displayed data
 * (including sorting, pagination, and filtering).
 */
var DataTableDataSource = /** @class */ (function (_super) {
    __extends(DataTableDataSource, _super);
    function DataTableDataSource(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    /**
     * Connect this data source to the table. The table will only update when
     * the returned stream emits new items.
     * @returns A stream of the items to be rendered.
     */
    DataTableDataSource.prototype.connect = function () {
        var _this = this;
        // Combine everything that affects the rendered data into one update
        // stream for the data-table to consume.
        var dataMutations = [
            observableOf(this.data),
            this.paginator.page,
            this.sort.sortChange,
        ];
        return merge.apply(void 0, __spread(dataMutations)).pipe(map(function () {
            return _this.getPagedData(_this.getSortedData(__spread(_this.data)));
        }));
    };
    /**
     *  Called when the table is being destroyed. Use this function, to clean up
     * any open connections or free any held resources that were set up during connect.
     */
    DataTableDataSource.prototype.disconnect = function () { };
    /**
     * Paginate the data (client-side). If you're using server-side pagination,
     * this would be replaced by requesting the appropriate data from the server.
     */
    DataTableDataSource.prototype.getPagedData = function (data) {
        var startIndex = this.paginator.pageIndex * this.paginator.pageSize;
        return data.splice(startIndex, this.paginator.pageSize);
    };
    /**
     * Sort the data (client-side). If you're using server-side sorting,
     * this would be replaced by requesting the appropriate data from the server.
     */
    DataTableDataSource.prototype.getSortedData = function (data) {
        var _this = this;
        if (!this.sort.active || this.sort.direction === "") {
            return data;
        }
        return data.sort(function (a, b) {
            var isAsc = _this.sort.direction === "asc";
            switch (_this.sort.active) {
                case "name":
                    return compare(a["name"], b["name"], isAsc);
                case "id":
                    return compare(+a["id"], +b["id"], isAsc);
                default:
                    return 0;
            }
        });
    };
    return DataTableDataSource;
}(DataSource));
export { DataTableDataSource };
/** Simple sort comparator for example ID/Name columns (for client-side sorting). */
function compare(a, b, isAsc) {
    return (a < b ? -1 : 1) * (isAsc ? 1 : -1);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctbS1kYXRhdGFibGUuZGF0YXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL21hdGVoLW5nLW0tZGF0YXRhYmxlLyIsInNvdXJjZXMiOlsibGliL25nLW0tZGF0YXRhYmxlLmRhdGFzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUd0RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFjLEVBQUUsSUFBSSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdELG1EQUFtRDtBQUNuRCxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixJQUFJO0FBRUo7Ozs7R0FJRztBQUNIO0lBQTRDLHVDQUFhO0lBS3ZELDZCQUFZLElBQWM7UUFBMUIsWUFDRSxpQkFBTyxTQUVSO1FBREMsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7O0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUNBQU8sR0FBUDtRQUFBLGlCQWNDO1FBYkMsb0VBQW9FO1FBQ3BFLHdDQUF3QztRQUN4QyxJQUFNLGFBQWEsR0FBRztZQUNwQixZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUk7WUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVO1NBQ3JCLENBQUM7UUFFRixPQUFPLEtBQUssd0JBQUksYUFBYSxHQUFFLElBQUksQ0FDakMsR0FBRyxDQUFDO1lBQ0YsT0FBTyxLQUFJLENBQUMsWUFBWSxDQUFDLEtBQUksQ0FBQyxhQUFhLFVBQUssS0FBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDL0QsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDSCx3Q0FBVSxHQUFWLGNBQWMsQ0FBQztJQUVmOzs7T0FHRztJQUNLLDBDQUFZLEdBQXBCLFVBQXFCLElBQWM7UUFDakMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7UUFDdEUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7O09BR0c7SUFDSywyQ0FBYSxHQUFyQixVQUFzQixJQUFjO1FBQXBDLGlCQWdCQztRQWZDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFLEVBQUU7WUFDbkQsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3BCLElBQU0sS0FBSyxHQUFHLEtBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQztZQUM1QyxRQUFRLEtBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUN4QixLQUFLLE1BQU07b0JBQ1QsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDOUMsS0FBSyxJQUFJO29CQUNQLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM1QztvQkFDRSxPQUFPLENBQUMsQ0FBQzthQUNaO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0gsMEJBQUM7QUFBRCxDQUFDLEFBbkVELENBQTRDLFVBQVUsR0FtRXJEOztBQUVELG9GQUFvRjtBQUNwRixTQUFTLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUs7SUFDMUIsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhU291cmNlIH0gZnJvbSBcIkBhbmd1bGFyL2Nkay9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHsgTWF0UGFnaW5hdG9yIH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL3BhZ2luYXRvclwiO1xuaW1wb3J0IHsgTWF0U29ydCB9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC9zb3J0XCI7XG5pbXBvcnQgeyBtYXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZiwgbWVyZ2UgfSBmcm9tIFwicnhqc1wiO1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCB5b3VyIG93biBkYXRhIG1vZGVsIHR5cGVcbi8vIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVRhYmxlSXRlbSB7XG4vLyAgIG5hbWU6IHN0cmluZztcbi8vICAgaWQ6IG51bWJlcjtcbi8vIH1cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgdGhlIERhdGFUYWJsZSB2aWV3LiBUaGlzIGNsYXNzIHNob3VsZFxuICogZW5jYXBzdWxhdGUgYWxsIGxvZ2ljIGZvciBmZXRjaGluZyBhbmQgbWFuaXB1bGF0aW5nIHRoZSBkaXNwbGF5ZWQgZGF0YVxuICogKGluY2x1ZGluZyBzb3J0aW5nLCBwYWdpbmF0aW9uLCBhbmQgZmlsdGVyaW5nKS5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFUYWJsZURhdGFTb3VyY2U8VD4gZXh0ZW5kcyBEYXRhU291cmNlPFQ+IHtcbiAgZGF0YTogQXJyYXk8VD47XG4gIHBhZ2luYXRvcjogTWF0UGFnaW5hdG9yO1xuICBzb3J0OiBNYXRTb3J0O1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IEFycmF5PFQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdGhpcyBkYXRhIHNvdXJjZSB0byB0aGUgdGFibGUuIFRoZSB0YWJsZSB3aWxsIG9ubHkgdXBkYXRlIHdoZW5cbiAgICogdGhlIHJldHVybmVkIHN0cmVhbSBlbWl0cyBuZXcgaXRlbXMuXG4gICAqIEByZXR1cm5zIEEgc3RyZWFtIG9mIHRoZSBpdGVtcyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGNvbm5lY3QoKTogT2JzZXJ2YWJsZTxBcnJheTxUPj4ge1xuICAgIC8vIENvbWJpbmUgZXZlcnl0aGluZyB0aGF0IGFmZmVjdHMgdGhlIHJlbmRlcmVkIGRhdGEgaW50byBvbmUgdXBkYXRlXG4gICAgLy8gc3RyZWFtIGZvciB0aGUgZGF0YS10YWJsZSB0byBjb25zdW1lLlxuICAgIGNvbnN0IGRhdGFNdXRhdGlvbnMgPSBbXG4gICAgICBvYnNlcnZhYmxlT2YodGhpcy5kYXRhKSxcbiAgICAgIHRoaXMucGFnaW5hdG9yLnBhZ2UsXG4gICAgICB0aGlzLnNvcnQuc29ydENoYW5nZSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIG1lcmdlKC4uLmRhdGFNdXRhdGlvbnMpLnBpcGUoXG4gICAgICBtYXAoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlZERhdGEodGhpcy5nZXRTb3J0ZWREYXRhKFsuLi50aGlzLmRhdGFdKSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBpcyBiZWluZyBkZXN0cm95ZWQuIFVzZSB0aGlzIGZ1bmN0aW9uLCB0byBjbGVhbiB1cFxuICAgKiBhbnkgb3BlbiBjb25uZWN0aW9ucyBvciBmcmVlIGFueSBoZWxkIHJlc291cmNlcyB0aGF0IHdlcmUgc2V0IHVwIGR1cmluZyBjb25uZWN0LlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFBhZ2luYXRlIHRoZSBkYXRhIChjbGllbnQtc2lkZSkuIElmIHlvdSdyZSB1c2luZyBzZXJ2ZXItc2lkZSBwYWdpbmF0aW9uLFxuICAgKiB0aGlzIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IHJlcXVlc3RpbmcgdGhlIGFwcHJvcHJpYXRlIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRQYWdlZERhdGEoZGF0YTogQXJyYXk8VD4pIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5wYWdpbmF0b3IucGFnZUluZGV4ICogdGhpcy5wYWdpbmF0b3IucGFnZVNpemU7XG4gICAgcmV0dXJuIGRhdGEuc3BsaWNlKHN0YXJ0SW5kZXgsIHRoaXMucGFnaW5hdG9yLnBhZ2VTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBkYXRhIChjbGllbnQtc2lkZSkuIElmIHlvdSdyZSB1c2luZyBzZXJ2ZXItc2lkZSBzb3J0aW5nLFxuICAgKiB0aGlzIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IHJlcXVlc3RpbmcgdGhlIGFwcHJvcHJpYXRlIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTb3J0ZWREYXRhKGRhdGE6IEFycmF5PFQ+KSB7XG4gICAgaWYgKCF0aGlzLnNvcnQuYWN0aXZlIHx8IHRoaXMuc29ydC5kaXJlY3Rpb24gPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGlzQXNjID0gdGhpcy5zb3J0LmRpcmVjdGlvbiA9PT0gXCJhc2NcIjtcbiAgICAgIHN3aXRjaCAodGhpcy5zb3J0LmFjdGl2ZSkge1xuICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIHJldHVybiBjb21wYXJlKGFbXCJuYW1lXCJdLCBiW1wibmFtZVwiXSwgaXNBc2MpO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICByZXR1cm4gY29tcGFyZSgrYVtcImlkXCJdLCArYltcImlkXCJdLCBpc0FzYyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIFNpbXBsZSBzb3J0IGNvbXBhcmF0b3IgZm9yIGV4YW1wbGUgSUQvTmFtZSBjb2x1bW5zIChmb3IgY2xpZW50LXNpZGUgc29ydGluZykuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGlzQXNjKSB7XG4gIHJldHVybiAoYSA8IGIgPyAtMSA6IDEpICogKGlzQXNjID8gMSA6IC0xKTtcbn1cbiJdfQ==