import { DataSource } from "@angular/cdk/collections";
import { map } from "rxjs/operators";
import { of as observableOf, merge } from "rxjs";
// TODO: Replace this with your own data model type
// export interface DataTableItem {
//   name: string;
//   id: number;
// }
/**
 * Data source for the DataTable view. This class should
 * encapsulate all logic for fetching and manipulating the displayed data
 * (including sorting, pagination, and filtering).
 */
export class DataTableDataSource extends DataSource {
    constructor(data) {
        super();
        this.data = data;
    }
    /**
     * Connect this data source to the table. The table will only update when
     * the returned stream emits new items.
     * @returns A stream of the items to be rendered.
     */
    connect() {
        // Combine everything that affects the rendered data into one update
        // stream for the data-table to consume.
        const dataMutations = [
            observableOf(this.data),
            this.paginator.page,
            this.sort.sortChange,
        ];
        return merge(...dataMutations).pipe(map(() => {
            return this.getPagedData(this.getSortedData([...this.data]));
        }));
    }
    /**
     *  Called when the table is being destroyed. Use this function, to clean up
     * any open connections or free any held resources that were set up during connect.
     */
    disconnect() { }
    /**
     * Paginate the data (client-side). If you're using server-side pagination,
     * this would be replaced by requesting the appropriate data from the server.
     */
    getPagedData(data) {
        const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
        return data.splice(startIndex, this.paginator.pageSize);
    }
    /**
     * Sort the data (client-side). If you're using server-side sorting,
     * this would be replaced by requesting the appropriate data from the server.
     */
    getSortedData(data) {
        if (!this.sort.active || this.sort.direction === "") {
            return data;
        }
        return data.sort((a, b) => {
            const isAsc = this.sort.direction === "asc";
            switch (this.sort.active) {
                case "name":
                    return compare(a["name"], b["name"], isAsc);
                case "id":
                    return compare(+a["id"], +b["id"], isAsc);
                default:
                    return 0;
            }
        });
    }
}
/** Simple sort comparator for example ID/Name columns (for client-side sorting). */
function compare(a, b, isAsc) {
    return (a < b ? -1 : 1) * (isAsc ? 1 : -1);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctbS1kYXRhdGFibGUuZGF0YXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL21hdGVoLW5nLW0tZGF0YXRhYmxlLyIsInNvdXJjZXMiOlsibGliL25nLW0tZGF0YXRhYmxlLmRhdGFzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBR3RELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFN0QsbURBQW1EO0FBQ25ELG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLElBQUk7QUFFSjs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLG1CQUF1QixTQUFRLFVBQWE7SUFLdkQsWUFBWSxJQUFjO1FBQ3hCLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxPQUFPO1FBQ0wsb0VBQW9FO1FBQ3BFLHdDQUF3QztRQUN4QyxNQUFNLGFBQWEsR0FBRztZQUNwQixZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUk7WUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVO1NBQ3JCLENBQUM7UUFFRixPQUFPLEtBQUssQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FDakMsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9ELENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsVUFBVSxLQUFJLENBQUM7SUFFZjs7O09BR0c7SUFDSyxZQUFZLENBQUMsSUFBYztRQUNqQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztRQUN0RSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGFBQWEsQ0FBQyxJQUFjO1FBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFLEVBQUU7WUFDbkQsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxLQUFLLENBQUM7WUFDNUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDeEIsS0FBSyxNQUFNO29CQUNULE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzlDLEtBQUssSUFBSTtvQkFDUCxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDNUM7b0JBQ0UsT0FBTyxDQUFDLENBQUM7YUFDWjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBRUQsb0ZBQW9GO0FBQ3BGLFNBQVMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSztJQUMxQixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFTb3VyY2UgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQgeyBNYXRQYWdpbmF0b3IgfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWwvcGFnaW5hdG9yXCI7XG5pbXBvcnQgeyBNYXRTb3J0IH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL3NvcnRcIjtcbmltcG9ydCB7IG1hcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mLCBtZXJnZSB9IGZyb20gXCJyeGpzXCI7XG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIHlvdXIgb3duIGRhdGEgbW9kZWwgdHlwZVxuLy8gZXhwb3J0IGludGVyZmFjZSBEYXRhVGFibGVJdGVtIHtcbi8vICAgbmFtZTogc3RyaW5nO1xuLy8gICBpZDogbnVtYmVyO1xuLy8gfVxuXG4vKipcbiAqIERhdGEgc291cmNlIGZvciB0aGUgRGF0YVRhYmxlIHZpZXcuIFRoaXMgY2xhc3Mgc2hvdWxkXG4gKiBlbmNhcHN1bGF0ZSBhbGwgbG9naWMgZm9yIGZldGNoaW5nIGFuZCBtYW5pcHVsYXRpbmcgdGhlIGRpc3BsYXllZCBkYXRhXG4gKiAoaW5jbHVkaW5nIHNvcnRpbmcsIHBhZ2luYXRpb24sIGFuZCBmaWx0ZXJpbmcpLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YVRhYmxlRGF0YVNvdXJjZTxUPiBleHRlbmRzIERhdGFTb3VyY2U8VD4ge1xuICBkYXRhOiBBcnJheTxUPjtcbiAgcGFnaW5hdG9yOiBNYXRQYWdpbmF0b3I7XG4gIHNvcnQ6IE1hdFNvcnQ7XG5cbiAgY29uc3RydWN0b3IoZGF0YTogQXJyYXk8VD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB0aGlzIGRhdGEgc291cmNlIHRvIHRoZSB0YWJsZS4gVGhlIHRhYmxlIHdpbGwgb25seSB1cGRhdGUgd2hlblxuICAgKiB0aGUgcmV0dXJuZWQgc3RyZWFtIGVtaXRzIG5ldyBpdGVtcy5cbiAgICogQHJldHVybnMgQSBzdHJlYW0gb2YgdGhlIGl0ZW1zIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgY29ubmVjdCgpOiBPYnNlcnZhYmxlPEFycmF5PFQ+PiB7XG4gICAgLy8gQ29tYmluZSBldmVyeXRoaW5nIHRoYXQgYWZmZWN0cyB0aGUgcmVuZGVyZWQgZGF0YSBpbnRvIG9uZSB1cGRhdGVcbiAgICAvLyBzdHJlYW0gZm9yIHRoZSBkYXRhLXRhYmxlIHRvIGNvbnN1bWUuXG4gICAgY29uc3QgZGF0YU11dGF0aW9ucyA9IFtcbiAgICAgIG9ic2VydmFibGVPZih0aGlzLmRhdGEpLFxuICAgICAgdGhpcy5wYWdpbmF0b3IucGFnZSxcbiAgICAgIHRoaXMuc29ydC5zb3J0Q2hhbmdlLFxuICAgIF07XG5cbiAgICByZXR1cm4gbWVyZ2UoLi4uZGF0YU11dGF0aW9ucykucGlwZShcbiAgICAgIG1hcCgoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VkRGF0YSh0aGlzLmdldFNvcnRlZERhdGEoWy4uLnRoaXMuZGF0YV0pKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQ2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGJlaW5nIGRlc3Ryb3llZC4gVXNlIHRoaXMgZnVuY3Rpb24sIHRvIGNsZWFuIHVwXG4gICAqIGFueSBvcGVuIGNvbm5lY3Rpb25zIG9yIGZyZWUgYW55IGhlbGQgcmVzb3VyY2VzIHRoYXQgd2VyZSBzZXQgdXAgZHVyaW5nIGNvbm5lY3QuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge31cblxuICAvKipcbiAgICogUGFnaW5hdGUgdGhlIGRhdGEgKGNsaWVudC1zaWRlKS4gSWYgeW91J3JlIHVzaW5nIHNlcnZlci1zaWRlIHBhZ2luYXRpb24sXG4gICAqIHRoaXMgd291bGQgYmUgcmVwbGFjZWQgYnkgcmVxdWVzdGluZyB0aGUgYXBwcm9wcmlhdGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBwcml2YXRlIGdldFBhZ2VkRGF0YShkYXRhOiBBcnJheTxUPikge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLnBhZ2luYXRvci5wYWdlSW5kZXggKiB0aGlzLnBhZ2luYXRvci5wYWdlU2l6ZTtcbiAgICByZXR1cm4gZGF0YS5zcGxpY2Uoc3RhcnRJbmRleCwgdGhpcy5wYWdpbmF0b3IucGFnZVNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIGRhdGEgKGNsaWVudC1zaWRlKS4gSWYgeW91J3JlIHVzaW5nIHNlcnZlci1zaWRlIHNvcnRpbmcsXG4gICAqIHRoaXMgd291bGQgYmUgcmVwbGFjZWQgYnkgcmVxdWVzdGluZyB0aGUgYXBwcm9wcmlhdGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBwcml2YXRlIGdldFNvcnRlZERhdGEoZGF0YTogQXJyYXk8VD4pIHtcbiAgICBpZiAoIXRoaXMuc29ydC5hY3RpdmUgfHwgdGhpcy5zb3J0LmRpcmVjdGlvbiA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgaXNBc2MgPSB0aGlzLnNvcnQuZGlyZWN0aW9uID09PSBcImFzY1wiO1xuICAgICAgc3dpdGNoICh0aGlzLnNvcnQuYWN0aXZlKSB7XG4gICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYVtcIm5hbWVcIl0sIGJbXCJuYW1lXCJdLCBpc0FzYyk7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIHJldHVybiBjb21wYXJlKCthW1wiaWRcIl0sICtiW1wiaWRcIl0sIGlzQXNjKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKiogU2ltcGxlIHNvcnQgY29tcGFyYXRvciBmb3IgZXhhbXBsZSBJRC9OYW1lIGNvbHVtbnMgKGZvciBjbGllbnQtc2lkZSBzb3J0aW5nKS4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgaXNBc2MpIHtcbiAgcmV0dXJuIChhIDwgYiA/IC0xIDogMSkgKiAoaXNBc2MgPyAxIDogLTEpO1xufVxuIl19