import { __decorate } from "tslib";
import { ViewChildren, ElementRef } from "@angular/core";
import { FormControlName, FormGroup, FormArray, } from "@angular/forms";
import { fromEvent, merge } from "rxjs";
import { debounceTime } from "rxjs/operators";
import * as ɵngcc0 from '@angular/core';
export class FormComponentBase {
    constructor() {
        this.validationMessages = {};
        this.formErrors = {};
    }
    startControlMonitoring(form, unsubscribePreviousForm = false) {
        if (unsubscribePreviousForm) {
            this.mySubs.unsubscribe();
        }
        // Watch for the blur event from any input element on the form.
        //  This is required because the valueChanges does not provide notification on blur.
        this.subscribe(form, this.formInputElements.toArray());
        this.formInputElements.changes.subscribe((inputs) => {
            this.subscribe(form, inputs.toArray());
        });
    }
    subscribe(form, inputsArray) {
        // console.log(inputsArray);
        const controlBlurs = inputsArray.map((formControl) => fromEvent(formControl.nativeElement, "blur"));
        // Merge the blur event observable with the valueChanges observable so we only need to subscribe once.
        this.mySubs = merge(form.valueChanges, ...controlBlurs)
            .pipe(debounceTime(300))
            .subscribe((value) => {
            this.logValidationErrors(form);
        });
    }
    logValidationErrors(group) {
        Object.keys(group.controls).forEach((key) => {
            const abstractControl = group.get(key);
            this.formErrors[key] = "";
            // console.log(key, abstractControl.invalid, abstractControl.touched, abstractControl.dirty);
            if (abstractControl &&
                !abstractControl.valid &&
                (abstractControl.touched || abstractControl.dirty)) {
                const messages = this.validationMessages[key];
                for (const errorKey in abstractControl.errors) {
                    if (errorKey) {
                        this.formErrors[key] += messages[errorKey] + " ";
                    }
                }
            }
            // console.log(this.formErrors);
            if (abstractControl instanceof FormGroup ||
                abstractControl instanceof FormArray) {
                this.logValidationErrors(abstractControl);
            }
        });
    }
    atLeastOneCheckboxCheckedValidator(minRequired = 1) {
        return function validate(formGroup) {
            let checked = 0;
            Object.keys(formGroup.controls).forEach((key) => {
                const control = formGroup.controls[key];
                if (control.value) {
                    checked++;
                }
            });
            if (checked < minRequired) {
                return {
                    requireCheckboxToBeChecked: true,
                };
            }
            return null;
        };
    }
    passwordsMustMatchValidator() {
        return (group) => {
            const currentPassword = group.get("password");
            const newPassword = group.get("confirmPassword");
            if (currentPassword && newPassword) {
                if (currentPassword.pristine || newPassword.pristine) {
                    return null;
                }
                if (currentPassword.value !== newPassword.value) {
                    return { passwordsMustMatch: true };
                }
            }
            return null;
        };
    }
    ngOnDestroy() {
        this.mySubs.unsubscribe();
    }
}
FormComponentBase.ɵfac = function FormComponentBase_Factory(t) { return new (t || FormComponentBase)(); };
FormComponentBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FormComponentBase, viewQuery: function FormComponentBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(FormControlName, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formInputElements = _t);
    } } });
__decorate([
    ViewChildren(FormControlName, { read: ElementRef })
], FormComponentBase.prototype, "formInputElements", void 0);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1jb21wb25lbnQtYmFzZS5qcyIsInNvdXJjZXMiOlsibmc6L21hdGVoLW5nLW0tdmFsaWRhdGlvbi9saWIvZm9ybS1jb21wb25lbnQtYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQXdCLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFDTCxlQUFlLEVBQ2YsU0FBUyxFQUNULFNBQVMsR0FHVixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFBYyxTQUFTLEVBQUUsS0FBSyxFQUE0QixNQUFNLE1BQU0sQ0FBQztBQUM5RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBRTlDLE1BQU0sT0FBTyxpQkFBaUI7SUFBOUI7UUFJUyx1QkFBa0IsR0FBaUQsRUFBRSxDQUFDO1FBQ3RFLGVBQVUsR0FBOEIsRUFBRSxDQUFDO0lBNEdwRCxDQUFDO0lBeEdXLHNCQUFzQixDQUM5QixJQUFlLEVBQ2YsdUJBQXVCLEdBQUcsS0FBSztRQUUvQixJQUFJLHVCQUF1QixFQUFFO1lBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDM0I7UUFDRCwrREFBK0Q7UUFDL0Qsb0ZBQW9GO1FBQ3BGLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRXZELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUN0QyxDQUFDLE1BQTZCLEVBQUUsRUFBRTtZQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUN6QyxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUM7SUFFTyxTQUFTLENBQUMsSUFBZSxFQUFFLFdBQXlCO1FBQzFELDRCQUE0QjtRQUM1QixNQUFNLFlBQVksR0FFWixXQUFXLENB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RUFBRSxJQUFJLEVBQUUsQ0FBQztpQkFDckM7YUFDRjtZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzVCLENBQUM7Ozs7Ozs7O1dBQ0Y7QUEvR0M7SUFEQyxZQUFZLENBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxDQUFDOzREQUNYO0FBQzNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlld0NoaWxkcmVuLCBFbGVtZW50UmVmLCBRdWVyeUxpc3QsIE9uRGVzdHJveSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge1xuICBGb3JtQ29udHJvbE5hbWUsXG4gIEZvcm1Hcm91cCxcbiAgRm9ybUFycmF5LFxuICBWYWxpZGF0b3JGbixcbiAgVmFsaWRhdGlvbkVycm9ycyxcbn0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tRXZlbnQsIG1lcmdlLCBTdWJzY3JpYmVyLCBTdWJzY3JpcHRpb24gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XG5cbmV4cG9ydCBjbGFzcyBGb3JtQ29tcG9uZW50QmFzZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIEBWaWV3Q2hpbGRyZW4oRm9ybUNvbnRyb2xOYW1lLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgZm9ybUlucHV0RWxlbWVudHM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICBwdWJsaWMgdmFsaWRhdGlvbk1lc3NhZ2VzOiB7IFtrZXk6IHN0cmluZ106IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfSA9IHt9O1xuICBwdWJsaWMgZm9ybUVycm9yczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIG15U3ViczogU3Vic2NyaXB0aW9uO1xuXG4gIHByb3RlY3RlZCBzdGFydENvbnRyb2xNb25pdG9yaW5nKFxuICAgIGZvcm06IEZvcm1Hcm91cCxcbiAgICB1bnN1YnNjcmliZVByZXZpb3VzRm9ybSA9IGZhbHNlXG4gICk6IHZvaWQge1xuICAgIGlmICh1bnN1YnNjcmliZVByZXZpb3VzRm9ybSkge1xuICAgICAgdGhpcy5teVN1YnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLy8gV2F0Y2ggZm9yIHRoZSBibHVyIGV2ZW50IGZyb20gYW55IGlucHV0IGVsZW1lbnQgb24gdGhlIGZvcm0uXG4gICAgLy8gIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGUgdmFsdWVDaGFuZ2VzIGRvZXMgbm90IHByb3ZpZGUgbm90aWZpY2F0aW9uIG9uIGJsdXIuXG4gICAgdGhpcy5zdWJzY3JpYmUoZm9ybSwgdGhpcy5mb3JtSW5wdXRFbGVtZW50cy50b0FycmF5KCkpO1xuXG4gICAgdGhpcy5mb3JtSW5wdXRFbGVtZW50cy5jaGFuZ2VzLnN1YnNjcmliZShcbiAgICAgIChpbnB1dHM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPikgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZShmb3JtLCBpbnB1dHMudG9BcnJheSgpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmUoZm9ybTogRm9ybUdyb3VwLCBpbnB1dHNBcnJheTogRWxlbWVudFJlZltdKSB7XG4gICAgLy8gY29uc29sZS5sb2coaW5wdXRzQXJyYXkpO1xuICAgIGNvbnN0IGNvbnRyb2xCbHVyczogT2JzZXJ2YWJsZTxcbiAgICAgIGFueVxuICAgID5bXSA9IGlucHV0c0FycmF5Lm1hcCgoZm9ybUNvbnRyb2w6IEVsZW1lbnRSZWYpID0+XG4gICAgICBmcm9tRXZlbnQoZm9ybUNvbnRyb2wubmF0aXZlRWxlbWVudCwgXCJibHVyXCIpXG4gICAgKTtcblxuICAgIC8vIE1lcmdlIHRoZSBibHVyIGV2ZW50IG9ic2VydmFibGUgd2l0aCB0aGUgdmFsdWVDaGFuZ2VzIG9ic2VydmFibGUgc28gd2Ugb25seSBuZWVkIHRvIHN1YnNjcmliZSBvbmNlLlxuICAgIHRoaXMubXlTdWJzID0gbWVyZ2UoZm9ybS52YWx1ZUNoYW5nZXMsIC4uLmNvbnRyb2xCbHVycylcbiAgICAgIC5waXBlKGRlYm91bmNlVGltZSgzMDApKVxuICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5sb2dWYWxpZGF0aW9uRXJyb3JzKGZvcm0pO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGxvZ1ZhbGlkYXRpb25FcnJvcnMoZ3JvdXA6IEZvcm1Hcm91cCB8IEZvcm1BcnJheSk6IHZvaWQge1xuICAgIE9iamVjdC5rZXlzKGdyb3VwLmNvbnRyb2xzKS5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgYWJzdHJhY3RDb250cm9sID0gZ3JvdXAuZ2V0KGtleSk7XG5cbiAgICAgIHRoaXMuZm9ybUVycm9yc1trZXldID0gXCJcIjtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGtleSwgYWJzdHJhY3RDb250cm9sLmludmFsaWQsIGFic3RyYWN0Q29udHJvbC50b3VjaGVkLCBhYnN0cmFjdENvbnRyb2wuZGlydHkpO1xuICAgICAgaWYgKFxuICAgICAgICBhYnN0cmFjdENvbnRyb2wgJiZcbiAgICAgICAgIWFic3RyYWN0Q29udHJvbC52YWxpZCAmJlxuICAgICAgICAoYWJzdHJhY3RDb250cm9sLnRvdWNoZWQgfHwgYWJzdHJhY3RDb250cm9sLmRpcnR5KVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy52YWxpZGF0aW9uTWVzc2FnZXNba2V5XTtcbiAgICAgICAgZm9yIChjb25zdCBlcnJvcktleSBpbiBhYnN0cmFjdENvbnRyb2wuZXJyb3JzKSB7XG4gICAgICAgICAgaWYgKGVycm9yS2V5KSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnNba2V5XSArPSBtZXNzYWdlc1tlcnJvcktleV0gKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZm9ybUVycm9ycyk7XG4gICAgICBpZiAoXG4gICAgICAgIGFic3RyYWN0Q29udHJvbCBpbnN0YW5jZW9mIEZvcm1Hcm91cCB8fFxuICAgICAgICBhYnN0cmFjdENvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQXJyYXlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvZ1ZhbGlkYXRpb25FcnJvcnMoYWJzdHJhY3RDb250cm9sKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGF0TGVhc3RPbmVDaGVja2JveENoZWNrZWRWYWxpZGF0b3IobWluUmVxdWlyZWQgPSAxKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiBmdW5jdGlvbiB2YWxpZGF0ZShmb3JtR3JvdXA6IEZvcm1Hcm91cCB8IEZvcm1BcnJheSkge1xuICAgICAgbGV0IGNoZWNrZWQgPSAwO1xuXG4gICAgICBPYmplY3Qua2V5cyhmb3JtR3JvdXAuY29udHJvbHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBjb250cm9sID0gZm9ybUdyb3VwLmNvbnRyb2xzW2tleV07XG5cbiAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUpIHtcbiAgICAgICAgICBjaGVja2VkKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2hlY2tlZCA8IG1pblJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVxdWlyZUNoZWNrYm94VG9CZUNoZWNrZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cblxuICBwYXNzd29yZHNNdXN0TWF0Y2hWYWxpZGF0b3IoKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoZ3JvdXA6IEZvcm1Hcm91cCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYXNzd29yZCA9IGdyb3VwLmdldChcInBhc3N3b3JkXCIpO1xuICAgICAgY29uc3QgbmV3UGFzc3dvcmQgPSBncm91cC5nZXQoXCJjb25maXJtUGFzc3dvcmRcIik7XG5cbiAgICAgIGlmIChjdXJyZW50UGFzc3dvcmQgJiYgbmV3UGFzc3dvcmQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQYXNzd29yZC5wcmlzdGluZSB8fCBuZXdQYXNzd29yZC5wcmlzdGluZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UGFzc3dvcmQudmFsdWUgIT09IG5ld1Bhc3N3b3JkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGFzc3dvcmRzTXVzdE1hdGNoOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLm15U3Vicy51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iXX0=